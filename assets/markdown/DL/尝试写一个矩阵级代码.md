# 编程任务
输入一个数组，返回每个数字在数组的位置和数值的加和

# 不可训练的tensor

self.register_buffer('pe', pe)

之后如果想要使用这个，可以在self中查看

Variable(self.pe[:, :],requires_grad=False)


- 另一种方式是使用函数注解

    @torch.no_grad() 会改变requires_grad中的变量值

# 定义可训练的矩阵和向量

其中模型是否要梯度下降，也主要是由requires_grad=True决定



定义了之后需要进行初始化
```
def _init_weights(self, m):
    if isinstance(m, nn.Linear):
        trunc_normal_(m.weight, std=.02)
        if isinstance(m, nn.Linear) and m.bias is not None:
            nn.init.constant_(m.bias, 0)
    elif isinstance(m, nn.LayerNorm):
        nn.init.constant_(m.bias, 0)
        nn.init.constant_(m.weight, 1.0)
```

# 定义Module

# 训练


